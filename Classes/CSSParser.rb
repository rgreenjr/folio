# #!/usr/bin/env ruby
# 
# require 'rubygems'
# require 'treetop'
# 
# # Autogenerated from a Treetop grammar. Edits may be lost.
# 
# module CSS
#   include Treetop::Runtime
# 
#   def root
#     @root ||= :stylesheet
#   end
# 
#   module Stylesheet0
#     def whitespace1
#       elements[0]
#     end
# 
#     def smt
#       elements[1]
#     end
# 
#     def whitespace2
#       elements[2]
#     end
#   end
# 
#   module Stylesheet1
#     def statements
#       smt.elements
#     end
#     def rulesets
#       statements.select { |e| e.selector? }
#     end
#     def comments
#       statements.select { |e| e.comment? }
#     end
#     def to_s
#       statements.join("\n")
#     end
#   end
# 
#   def _nt_stylesheet
#     start_index = index
#     if node_cache[:stylesheet].has_key?(index)
#       cached = node_cache[:stylesheet][index]
#       if cached
#         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
#         @index = cached.interval.end
#       end
#       return cached
#     end
# 
#     i0, s0 = index, []
#     r1 = _nt_whitespace
#     s0 << r1
#     if r1
#       s2, i2 = [], index
#       loop do
#         r3 = _nt_statement
#         if r3
#           s2 << r3
#         else
#           break
#         end
#       end
#       r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
#       s0 << r2
#       if r2
#         r4 = _nt_whitespace
#         s0 << r4
#       end
#     end
#     if s0.last
#       r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
#       r0.extend(Stylesheet0)
#       r0.extend(Stylesheet1)
#     else
#       @index = i0
#       r0 = nil
#     end
# 
#     node_cache[:stylesheet][start_index] = r0
# 
#     r0
#   end
# 
#   def _nt_statement
#     start_index = index
#     if node_cache[:statement].has_key?(index)
#       cached = node_cache[:statement][index]
#       if cached
#         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
#         @index = cached.interval.end
#       end
#       return cached
#     end
# 
#     i0 = index
#     r1 = _nt_comment
#     if r1
#       r0 = r1
#     else
#       r2 = _nt_ruleset
#       if r2
#         r0 = r2
#       else
#         @index = i0
#         r0 = nil
#       end
#     end
# 
#     node_cache[:statement][start_index] = r0
# 
#     r0
#   end
# 
#   module Comment0
#     def whitespace1
#       elements[0]
#     end
# 
#     def comment_body
#       elements[2]
#     end
# 
#     def whitespace2
#       elements[4]
#     end
#   end
# 
#   module Comment1
#     def to_s
#       "/* #{comment_body} */"
#     end
#     def rule?
#       false
#     end
#   end
# 
#   def _nt_comment
#     start_index = index
#     if node_cache[:comment].has_key?(index)
#       cached = node_cache[:comment][index]
#       if cached
#         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
#         @index = cached.interval.end
#       end
#       return cached
#     end
# 
#     i0, s0 = index, []
#     r1 = _nt_whitespace
#     s0 << r1
#     if r1
#       if has_terminal?('/*', false, index)
#         r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
#         @index += 2
#       else
#         terminal_parse_failure('/*')
#         r2 = nil
#       end
#       s0 << r2
#       if r2
#         r3 = _nt_comment_body
#         s0 << r3
#         if r3
#           if has_terminal?('*/', false, index)
#             r4 = instantiate_node(SyntaxNode,input, index...(index + 2))
#             @index += 2
#           else
#             terminal_parse_failure('*/')
#             r4 = nil
#           end
#           s0 << r4
#           if r4
#             r5 = _nt_whitespace
#             s0 << r5
#           end
#         end
#       end
#     end
#     if s0.last
#       r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
#       r0.extend(Comment0)
#       r0.extend(Comment1)
#     else
#       @index = i0
#       r0 = nil
#     end
# 
#     node_cache[:comment][start_index] = r0
# 
#     r0
#   end
# 
#   module CommentBody0
#     def to_s
#       text_value
#     end
#   end
# 
#   def _nt_comment_body
#     start_index = index
#     if node_cache[:comment_body].has_key?(index)
#       cached = node_cache[:comment_body][index]
#       if cached
#         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
#         @index = cached.interval.end
#       end
#       return cached
#     end
# 
#     s0, i0 = [], index
#     loop do
#       if has_terminal?('\G[a-zA-Z0-9,;:+\\\'\\"\\!\\/\\(\\)\\-\\. ]', true, index)
#         r1 = true
#         @index += 1
#       else
#         r1 = nil
#       end
#       if r1
#         s0 << r1
#       else
#         break
#       end
#     end
#     r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
#     r0.extend(CommentBody0)
# 
#     node_cache[:comment_body][start_index] = r0
# 
#     r0
#   end
# 
#   module Ruleset0
#     def whitespace1
#       elements[0]
#     end
# 
#     def sel
#       elements[1]
#     end
# 
#     def whitespace2
#       elements[2]
#     end
# 
#     def whitespace3
#       elements[4]
#     end
# 
#     def dec
#       elements[5]
#     end
# 
#     def whitespace4
#       elements[6]
#     end
# 
#   end
# 
#   module Ruleset1
#       def selectors
#         sel.elements.sort_by {|x| x.text_value}
#       end 
#       def declarations
#         dec.elements.sort_by {|x| x.text_value}
#       end
#       def rule?
#        true
#       end
#       def to_s
#        selectors.join(", ") + " {\n  " + declarations.join(";\n  ") + ";\n}\n"
#       end
#   end
# 
#   def _nt_ruleset
#     start_index = index
#     if node_cache[:ruleset].has_key?(index)
#       cached = node_cache[:ruleset][index]
#       if cached
#         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
#         @index = cached.interval.end
#       end
#       return cached
#     end
# 
#     i0, s0 = index, []
#     r1 = _nt_whitespace
#     s0 << r1
#     if r1
#       s2, i2 = [], index
#       loop do
#         r3 = _nt_selector
#         if r3
#           s2 << r3
#         else
#           break
#         end
#       end
#       if s2.empty?
#         @index = i2
#         r2 = nil
#       else
#         r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
#       end
#       s0 << r2
#       if r2
#         r4 = _nt_whitespace
#         s0 << r4
#         if r4
#           if has_terminal?('{', false, index)
#             r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
#             @index += 1
#           else
#             terminal_parse_failure('{')
#             r5 = nil
#           end
#           s0 << r5
#           if r5
#             r6 = _nt_whitespace
#             s0 << r6
#             if r6
#               s7, i7 = [], index
#               loop do
#                 r8 = _nt_declaration
#                 if r8
#                   s7 << r8
#                 else
#                   break
#                 end
#               end
#               r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
#               s0 << r7
#               if r7
#                 r9 = _nt_whitespace
#                 s0 << r9
#                 if r9
#                   if has_terminal?('}', false, index)
#                     r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
#                     @index += 1
#                   else
#                     terminal_parse_failure('}')
#                     r10 = nil
#                   end
#                   s0 << r10
#                 end
#               end
#             end
#           end
#         end
#       end
#     end
#     if s0.last
#       r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
#       r0.extend(Ruleset0)
#       r0.extend(Ruleset1)
#     else
#       @index = i0
#       r0 = nil
#     end
# 
#     node_cache[:ruleset][start_index] = r0
# 
#     r0
#   end
# 
#   module Selector0
#     def key
#       elements[0]
#     end
# 
#     def whitespace
#       elements[2]
#     end
#   end
# 
#   module Selector1
#     def to_s
#       key.text_value.strip
#     end
#   end
# 
#   def _nt_selector
#     start_index = index
#     if node_cache[:selector].has_key?(index)
#       cached = node_cache[:selector][index]
#       if cached
#         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
#         @index = cached.interval.end
#       end
#       return cached
#     end
# 
#     i0, s0 = index, []
#     s1, i1 = [], index
#     loop do
#       if has_terminal?('\G[a-zA-Z0-9_#.:+~>=\\[\\]\\.\\-\\*\\\\\\" ]', true, index)
#         r2 = true
#         @index += 1
#       else
#         r2 = nil
#       end
#       if r2
#         s1 << r2
#       else
#         break
#       end
#     end
#     if s1.empty?
#       @index = i1
#       r1 = nil
#     else
#       r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
#     end
#     s0 << r1
#     if r1
#       if has_terminal?('\G[,]', true, index)
#         r4 = true
#         @index += 1
#       else
#         r4 = nil
#       end
#       if r4
#         r3 = r4
#       else
#         r3 = instantiate_node(SyntaxNode,input, index...index)
#       end
#       s0 << r3
#       if r3
#         r5 = _nt_whitespace
#         s0 << r5
#       end
#     end
#     if s0.last
#       r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
#       r0.extend(Selector0)
#       r0.extend(Selector1)
#     else
#       @index = i0
#       r0 = nil
#     end
# 
#     node_cache[:selector][start_index] = r0
# 
#     r0
#   end
# 
#   module Declaration0
#     def declaration_property
#       elements[0]
#     end
# 
#     def whitespace1
#       elements[1]
#     end
# 
#     def whitespace2
#       elements[3]
#     end
# 
#     def declaration_value
#       elements[4]
#     end
# 
#     def whitespace3
#       elements[6]
#     end
#   end
# 
#   module Declaration1
#     def property
#       declaration_property
#     end
#     def value
#       declaration_value
#     end
#     def to_s
#       "#{property}: #{value}"
#     end
#   end
# 
#   def _nt_declaration
#     start_index = index
#     if node_cache[:declaration].has_key?(index)
#       cached = node_cache[:declaration][index]
#       if cached
#         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
#         @index = cached.interval.end
#       end
#       return cached
#     end
# 
#     i0, s0 = index, []
#     r1 = _nt_declaration_property
#     s0 << r1
#     if r1
#       r2 = _nt_whitespace
#       s0 << r2
#       if r2
#         if has_terminal?(':', false, index)
#           r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
#           @index += 1
#         else
#           terminal_parse_failure(':')
#           r3 = nil
#         end
#         s0 << r3
#         if r3
#           r4 = _nt_whitespace
#           s0 << r4
#           if r4
#             r5 = _nt_declaration_value
#             s0 << r5
#             if r5
#               if has_terminal?(';', false, index)
#                 r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
#                 @index += 1
#               else
#                 terminal_parse_failure(';')
#                 r6 = nil
#               end
#               s0 << r6
#               if r6
#                 r7 = _nt_whitespace
#                 s0 << r7
#               end
#             end
#           end
#         end
#       end
#     end
#     if s0.last
#       r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
#       r0.extend(Declaration0)
#       r0.extend(Declaration1)
#     else
#       @index = i0
#       r0 = nil
#     end
# 
#     node_cache[:declaration][start_index] = r0
# 
#     r0
#   end
# 
#   module DeclarationProperty0
#     def to_s
#       text_value
#     end
#   end
# 
#   def _nt_declaration_property
#     start_index = index
#     if node_cache[:declaration_property].has_key?(index)
#       cached = node_cache[:declaration_property][index]
#       if cached
#         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
#         @index = cached.interval.end
#       end
#       return cached
#     end
# 
#     s0, i0 = [], index
#     loop do
#       if has_terminal?('\G[a-zA-Z0-9-]', true, index)
#         r1 = true
#         @index += 1
#       else
#         r1 = nil
#       end
#       if r1
#         s0 << r1
#       else
#         break
#       end
#     end
#     if s0.empty?
#       @index = i0
#       r0 = nil
#     else
#       r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
#       r0.extend(DeclarationProperty0)
#     end
# 
#     node_cache[:declaration_property][start_index] = r0
# 
#     r0
#   end
# 
#   module DeclarationValue0
#     def to_s
#       text_value
#     end
#   end
# 
#   def _nt_declaration_value
#     start_index = index
#     if node_cache[:declaration_value].has_key?(index)
#       cached = node_cache[:declaration_value][index]
#       if cached
#         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
#         @index = cached.interval.end
#       end
#       return cached
#     end
# 
#     s0, i0 = [], index
#     loop do
#       if has_terminal?('\G[a-zA-Z0-9%#,!:\\/\\.\\-\\\'\\(\\) ]', true, index)
#         r1 = true
#         @index += 1
#       else
#         r1 = nil
#       end
#       if r1
#         s0 << r1
#       else
#         break
#       end
#     end
#     if s0.empty?
#       @index = i0
#       r0 = nil
#     else
#       r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
#       r0.extend(DeclarationValue0)
#     end
# 
#     node_cache[:declaration_value][start_index] = r0
# 
#     r0
#   end
# 
#   def _nt_whitespace
#     start_index = index
#     if node_cache[:whitespace].has_key?(index)
#       cached = node_cache[:whitespace][index]
#       if cached
#         cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
#         @index = cached.interval.end
#       end
#       return cached
#     end
# 
#     s0, i0 = [], index
#     loop do
#       if has_terminal?('\G[\\s]', true, index)
#         r1 = true
#         @index += 1
#       else
#         r1 = nil
#       end
#       if r1
#         s0 << r1
#       else
#         break
#       end
#     end
#     r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
# 
#     node_cache[:whitespace][start_index] = r0
# 
#     r0
#   end
# 
# end
# 
# class CSSParser < Treetop::Runtime::CompiledParser
#   include CSS
# end
# 
# 
# file = '/Users/rgreen/code/ruby/css-parser/test/test2.css'
# parser = CSSParser.new
# result = parser.parse(IO.read(file))
# puts result
# raise "Failed to parse CSS file: " + parser.failure_reason unless result
